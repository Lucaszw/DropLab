import { Button , Label, Segment} from 'semantic-ui-react'

class Procedure extends React.Component {
  constructor(props){
    super(props);

    this.addStepBtn  = {icon: "plus", content: "Add", color: "green"};
    this.stopBtn = {icon: "square", content: "Stop", color: "yellow"};
    this.playBtn = {icon: "play", content: "Play", color: "blue"};
    this.loopBtn = {icon: "repeat", content: "Loop", color: "orange"};

    this.removeStepBtn = {icon: "remove", content: "Remove", color: "red"};

    this.modes = {
      running: "running",
      looping: "looping",
      stopped: "stopped"
    };

    this.state = {
      electrodeSequence: this.props.sequence.sequence,
      mode: this.modes.stopped,
      sequenceIndex: props.sequenceIndex
    };
  }

  getPlayBtn(){
    return this.state.mode == this.modes.stopped ? this.playBtn : this.stopBtn;
  }
  getLoopBtn(){
    let btn = this.loopBtn;
    if (this.state.mode != this.modes.stopped){btn.disabled = true}
    else{delete btn.disabled}
    return btn;
  }

  toggleDisabledButtons(){
    if (this.state.mode != this.modes.stopped){
      this.addStepBtn.disabled = true;
      this.removeStepBtn.disabled = true;
    }else {
      delete this.addStepBtn.disabled;
      delete this.removeStepBtn.disabled;
    };
  }

  handleAddStepClicked(e){
    e.preventDefault();
    this.props.sequence.addStep(this);
  }

  handleChangeModeClicked(e){
    e.preventDefault();
    if (this.state.mode == this.modes.stopped){
      let self = this;
      this.setState({mode: this.modes.running}, function(){
        this.props.sequence.runRecipe(self);
      });
    }else{
      this.setState({mode: this.modes.stopped, sequenceIndex: 0});
    }
  }

  handleLoopModeClicked(e){
    e.preventDefault();
    if (this.state.mode == this.modes.stopped){
      let self = this;
      this.setState({mode: this.modes.looping}, function(){
        this.props.sequence.runRecipe(self);
      });
    }
  }

  handleRemoveStepClicked(e){
    e.preventDefault();
    this.props.sequence.removeStep(this);
  }

  handleLoadClicked(e){

    e.preventDefault();
    var file = e.target.files[0];
    if (!file) return;

    var reader = new FileReader();
    var self = this;
    reader.onload = function(e) {
      var contents = JSON.parse(e.target.result);
      self.setState({electrodeSequence: contents, sequenceIndex: 0});
    };
    reader.readAsText(file);

  }

  handleSaveClicked(e){
    e.preventDefault();

    var url = 'data:text/json;charset=utf8,' +
        encodeURIComponent(JSON.stringify(this.state.electrodeSequence));
    window.open(url, '_blank');
    window.focus();
  }

  render() {

    const playBtn = this.getPlayBtn();
    const loopBtn = this.getLoopBtn();

    const handleAddStepClicked = this.handleAddStepClicked.bind(this);
    const handleChangeModeClicked = this.handleChangeModeClicked.bind(this);
    const handleRemoveStepClicked = this.handleRemoveStepClicked.bind(this);
    const handleSaveClicked = this.handleSaveClicked.bind(this);
    const handleLoadClicked = this.handleLoadClicked.bind(this);
    const handleLoopModeClicked = this.handleLoopModeClicked.bind(this);


    this.toggleDisabledButtons();

    let steps = _.map(this.state.electrodeSequence, function(step){
      let txt = step.join(",").slice(0,20);
      if (txt.length >= 20)
        txt += "...";
      return <Segment textAlign='center' >{txt}</Segment>
    });

    return (
      <Segment.Group>
        <Segment textAlign='center' >
          <Button circular size='mini' onClick={handleAddStepClicked}
            {...this.addStepBtn} />
          <Button circular size='mini' onClick={handleRemoveStepClicked}
            {...this.removeStepBtn} />
          <Button circular size='mini' onClick={handleChangeModeClicked}
            {...playBtn} />
          <Button circular size='mini' onClick={handleLoopModeClicked}
            {...loopBtn} />
        </Segment>
        <Segment textAlign='center' >
          <Button size='mini' content="Save Recipe" color="teal"
            onClick={handleSaveClicked} />
          <Procedure.FileUpload size='mini' content="Load Recipe" color="purple"
            onClick={handleLoadClicked} />
        </Segment>
        {steps}
      </Segment.Group>
    )
  }
}

Procedure.Sequence = class {
  // Use this class to interface between SVG Reader and Procedure
  // can run receipes generated by the procedure class
  // step by step
  constructor(props){
    this.activeElectrodes = new Array();
    this.sequence = new Array();
    this.svgReader = props.svgReader;
  }

  addStep(procedure){
    if (!this.activeElectrodes) return;

    this.sequence.push(this.activeElectrodes);
    procedure.setState({electrodeSequence: this.sequence});
  }

  loadStep(procedure){
    if (procedure.state.sequenceIndex < 0 ||
          procedure.state.sequenceIndex >= procedure.state.electrodeSequence.length)
      return;


    this.svgReader.setActive(
      procedure.state.electrodeSequence[procedure.state.sequenceIndex]
    );

    procedure.setState({sequenceIndex: procedure.state.sequenceIndex+1});
  };

  removeStep(procedure){
    if (!this.sequence.length) return;

    this.sequence.pop();
    procedure.setState({electrodeSequence: this.sequence});
  }

  runRecipe(procedure){
    let self = this;

    let atEndOfSequence = (procedure.state.sequenceIndex >= procedure.state.electrodeSequence.length);
    let isLooping = (procedure.state.mode == procedure.modes.looping);
    let isRunning = (procedure.state.mode != procedure.modes.stopped);
    let keepRunning = true;

    // If looping and sequence is over, start running again:
    if (atEndOfSequence && isLooping){
      procedure.setState({sequenceIndex: 0}, function(){
        self.loadStep(procedure);
        setTimeout(function(){self.runRecipe(procedure)}, 1000);
      });
      return;
    }

    // If not at end of sequence, run the next step in procedure
    if(!atEndOfSequence && isRunning) {
      self.loadStep(procedure);
      setTimeout(function(){self.runRecipe(procedure)}, 1000);
      return;
    }

    // End procedure if above to cases were not executed:
    procedure.setState({mode: procedure.modes.stopped});

  }

  setActiveElectrodes(arr){this.activeElectrodes = arr;}
  setSVGReader(reader){this.svgReader = reader;}

}

Procedure.FileUpload = class extends React.Component {

  constructor(props){
    super(props);
    this.styles = {
      container: {
        position: "relative",
        overflow: "hidden"
      },
      input: {
        position: "absolute",
        top: 0,
        right: 0,
        minWidth: "100%",
        minHeight: "100%",
        fontSize: "100px",
        textAlign: "right",
        filter: "alpha(opacity=0)",
        opacity: 0,
        outline: "none",
        background: "white",
        cursor: "inherit",
        display: "block"
      }
    };
  }

  render(){
    const btnProps = _.omit(this.props, ['onClick','content']);

    return (
      <Button style={this.styles.container} {...btnProps} >
          {this.props.content} <input type="file" style={this.styles.input}
              onChange={this.props.onClick}/>
      </Button>
    );
  }

}

export default Procedure;
